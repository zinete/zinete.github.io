<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何理解 JavaScript 中的事件循环</title>
    <link href="/2024/07/12/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20JavaScript%20%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2024/07/12/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20JavaScript%20%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="如何理解-JavaScript-中的事件循环（Event-Loop）"><a href="#如何理解-JavaScript-中的事件循环（Event-Loop）" class="headerlink" title="如何理解 JavaScript 中的事件循环（Event Loop）"></a>如何理解 JavaScript 中的事件循环（Event Loop）</h1><p>JavaScript 是一种<strong>单线程</strong>语言，它通过事件循环（Event Loop）机制来实现异步操作的调度与执行。理解事件循环有助于我们更好地编写异步代码，避免一些常见的“回调陷阱”或异步顺序错误。</p><hr><p><img src="/../img/eventloop.png" alt="示意图"></p><h2 id="1-什么是事件循环？"><a href="#1-什么是事件循环？" class="headerlink" title="1. 什么是事件循环？"></a>1. 什么是事件循环？</h2><p>事件循环是一种协调机制，用于决定哪些代码在何时执行，特别是在处理异步任务（如定时器、网络请求、Promise 等）时。事件循环的核心流程包括：</p><ol><li>执行同步代码（同步任务进入调用栈）</li><li>执行所有微任务（Microtasks）</li><li>从宏任务队列中取出下一个宏任务执行</li><li>重复上述过程</li></ol><hr><h2 id="2-同步任务-vs-异步任务"><a href="#2-同步任务-vs-异步任务" class="headerlink" title="2. 同步任务 vs 异步任务"></a>2. 同步任务 vs 异步任务</h2><ul><li><strong>同步任务</strong>：立即执行，按顺序排列在调用栈中。</li><li><strong>异步任务</strong>：交由浏览器或 Node 的 Web API 执行，完成后加入任务队列中等待执行。</li></ul><hr><h2 id="3-微任务与宏任务"><a href="#3-微任务与宏任务" class="headerlink" title="3. 微任务与宏任务"></a>3. 微任务与宏任务</h2><table><thead><tr><th>类型</th><th>举例</th><th>特点</th></tr></thead><tbody><tr><td><strong>微任务 Microtask</strong></td><td>Promise.then、MutationObserver、queueMicrotask</td><td>在当前宏任务完成后立即执行</td></tr><tr><td><strong>宏任务 MacroTask</strong></td><td>setTimeout、setInterval、I&#x2F;O、setImmediate</td><td>会排队等待事件循环进入下一个周期</td></tr></tbody></table><hr><h2 id="4-执行顺序示例"><a href="#4-执行顺序示例" class="headerlink" title="4. 执行顺序示例"></a>4. 执行顺序示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3&quot;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;4&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span>;<br><span class="hljs-number">4</span>;<br><span class="hljs-number">3</span>;<br><span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h3 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h3><ol><li><code>console.log(&#39;1&#39;)</code> 和 <code>console.log(&#39;4&#39;)</code> 是同步任务，先执行。</li><li><code>setTimeout</code> 是宏任务，进入任务队列。</li><li><code>Promise.then</code> 是微任务，在当前宏任务执行完后立即执行。</li><li>所以先输出 3，然后才是 <code>setTimeout</code> 的 2。</li></ol><h2 id="5-setTimeout-fn-0-并不是“立即执行”"><a href="#5-setTimeout-fn-0-并不是“立即执行”" class="headerlink" title="5. setTimeout(fn, 0) 并不是“立即执行”"></a>5. setTimeout(fn, 0) 并不是“立即执行”</h2><p>即便设置为 0 毫秒，setTimeout 回调也不会在当前调用栈执行完前运行，因为它是宏任务，会等到所有当前宏任务和微任务完成后才进入执行。</p><h2 id="6-实战技巧：分批执行避免阻塞"><a href="#6-实战技巧：分批执行避免阻塞" class="headerlink" title="6. 实战技巧：分批执行避免阻塞"></a>6. 实战技巧：分批执行避免阻塞</h2><p>如果你有一个很大的循环操作，不建议一次性执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不推荐：可能阻塞 UI</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e9</span>; i++) &#123;<br>  <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以改为使用 setTimeout 分批执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">chunkedTask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>    <span class="hljs-comment">// do something</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (moreWork) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(chunkedTask, <span class="hljs-number">0</span>); <span class="hljs-comment">// 让出执行权</span><br>  &#125;<br>&#125;<br><span class="hljs-title function_">chunkedTask</span>();<br></code></pre></td></tr></table></figure><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><ul><li><code>JavaScript</code> 是单线程语言，通过事件循环处理异步任务。微任务优先于宏任务执行。</li><li><code>Promise.then</code> 总是在同步任务之后，<code>setTimeout</code> 之后执行。</li><li>理解事件循环，有助于编写更加流畅、性能更佳的前端应用。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些问题记录</title>
    <link href="/2023/05/07/%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/05/07/%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一些问题记录"><a href="#一些问题记录" class="headerlink" title="一些问题记录"></a>一些问题记录</h1><blockquote><p>git 代码提交验证问题</p></blockquote><p>配置 gpg 之后如果提交代码失败，需要在终端执行<code> export GPG_TTY=$(tty)</code><br>然后再次提交，按照提示输入 gpg 配置的密码即可</p><p><code>gpg --full-generate-key</code> 交互式命令创建新的 gpg key</p><p><code>gpg --list-keys</code> 查看创建的所有 gpg key</p><p><code>gpg --armor --export zhenghui@zinete.com</code> 查看指定邮箱 gpg 公钥</p>]]></content>
    
    
    
    <tags>
      
      <tag>问题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手动执行添加SSH密钥</title>
    <link href="/2022/10/04/%E6%89%8B%E5%8A%A8%E6%89%A7%E8%A1%8C%E6%B7%BB%E5%8A%A0SSH%E5%AF%86%E9%92%A5/"/>
    <url>/2022/10/04/%E6%89%8B%E5%8A%A8%E6%89%A7%E8%A1%8C%E6%B7%BB%E5%8A%A0SSH%E5%AF%86%E9%92%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="自动加载-SSH-密钥并使用-macOS-钥匙串"><a href="#自动加载-SSH-密钥并使用-macOS-钥匙串" class="headerlink" title="自动加载 SSH 密钥并使用 macOS 钥匙串"></a>自动加载 SSH 密钥并使用 macOS 钥匙串</h1><p>为了避免每次重启机器都需要执行 <code>ssh-add --apple-use-keychain</code> 命令，可以按照以下步骤进行配置：</p><h2 id="1-确保-SSH-密钥已添加到钥匙串"><a href="#1-确保-SSH-密钥已添加到钥匙串" class="headerlink" title="1. 确保 SSH 密钥已添加到钥匙串"></a>1. 确保 SSH 密钥已添加到钥匙串</h2><p>执行以下命令，将密钥永久添加到钥匙串中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-add --apple-use-keychain ~/.ssh/zinete.com<br></code></pre></td></tr></table></figure><h2 id="2-配置-SSH-客户端加载密钥"><a href="#2-配置-SSH-客户端加载密钥" class="headerlink" title="2. 配置 SSH 客户端加载密钥"></a>2. 配置 SSH 客户端加载密钥</h2><p>编辑或创建 <code>~/.ssh/config</code> 文件，添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Host *<br>  AddKeysToAgent yes<br>  UseKeychain yes<br>  IdentityFile ~/.ssh/zinete.com<br></code></pre></td></tr></table></figure><h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><ul><li><code>AddKeysToAgent yes</code>：自动将密钥添加到 SSH Agent。</li><li><code>UseKeychain yes</code>：允许密钥存储在 macOS 钥匙串中。</li><li><code>IdentityFile</code>：指定使用的私钥文件。</li></ul><h2 id="3-确保-SSH-Agent-启动"><a href="#3-确保-SSH-Agent-启动" class="headerlink" title="3. 确保 SSH Agent 启动"></a>3. 确保 SSH Agent 启动</h2><p>macOS 默认会启动 SSH Agent，但可以手动验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ssh-agent -s)</span>&quot;</span><br></code></pre></td></tr></table></figure><h2 id="4-验证配置"><a href="#4-验证配置" class="headerlink" title="4. 验证配置"></a>4. 验证配置</h2><p>执行以下命令检查密钥是否自动加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-add -l<br></code></pre></td></tr></table></figure><p>如果显示了密钥的指纹，说明配置成功。</p><hr><p>通过上述配置，SSH 密钥将在重启后自动从 macOS 钥匙串加载，无需手动执行 <code>ssh-add</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Session和Cookie的区别</title>
    <link href="/2022/06/03/Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/06/03/Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="Session-和-Cookie-的区别"><a href="#Session-和-Cookie-的区别" class="headerlink" title="Session 和 Cookie 的区别"></a>Session 和 Cookie 的区别</h1><p><code>session</code> 和 <code>cookie</code> 是用于在客户端与服务器之间保持状态的两种技术，它们有一些显著的区别：</p><h2 id="1-存储位置"><a href="#1-存储位置" class="headerlink" title="1. 存储位置"></a>1. 存储位置</h2><ul><li><strong>Cookie</strong><br>存储在客户端（浏览器），数据会随着每次请求自动发送到服务器。</li><li><strong>Session</strong><br>存储在服务器，客户端只保存一个唯一的 <code>session_id</code>，通过它找到对应的会话数据。</li></ul><h2 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h2><ul><li><strong>Cookie</strong><br>默认会在浏览器关闭后失效，除非设置了 <code>expires</code> 或 <code>max-age</code> 属性，可以持久存储。</li><li><strong>Session</strong><br>通常在用户关闭浏览器或服务器设定的超时时间到期后失效（如 30 分钟未操作）。</li></ul><h2 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3. 安全性"></a>3. 安全性</h2><ul><li><strong>Cookie</strong><br>数据存储在客户端，容易被窃取或篡改（如通过 XSS 攻击）。可以通过 <code>HttpOnly</code> 和 <code>Secure</code> 属性提高安全性。</li><li><strong>Session</strong><br>数据存储在服务器，安全性更高，但需要依赖 <code>session_id</code> 的安全传递和存储。</li></ul><h2 id="4-容量限制"><a href="#4-容量限制" class="headerlink" title="4. 容量限制"></a>4. 容量限制</h2><ul><li><strong>Cookie</strong><br>单个 Cookie 的大小限制为 4KB 左右，且每个域名最多存储 20 个左右（不同浏览器限制不同）。</li><li><strong>Session</strong><br>理论上不受容量限制，实际受服务器内存或存储空间的影响。</li></ul><h2 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5. 适用场景"></a>5. 适用场景</h2><ul><li><strong>Cookie</strong><br>常用于保存一些小型的、非敏感的数据，例如用户偏好设置、记住用户名等。</li><li><strong>Session</strong><br>常用于需要更高安全性或需要保存用户状态的场景，例如用户登录状态、购物车信息等。</li></ul><h2 id="6-性能影响"><a href="#6-性能影响" class="headerlink" title="6. 性能影响"></a>6. 性能影响</h2><ul><li><strong>Cookie</strong><br>由于每次请求都会附加到 HTTP 请求头中，大量使用可能增加网络开销。</li><li><strong>Session</strong><br>存储在服务器，会消耗服务器资源。如果并发用户过多，可能导致性能问题。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>特性</th><th>Cookie</th><th>Session</th></tr></thead><tbody><tr><td>存储位置</td><td>客户端</td><td>服务器</td></tr><tr><td>生命周期</td><td>可配置</td><td>浏览器关闭或超时后失效</td></tr><tr><td>安全性</td><td>易被窃取&#x2F;篡改</td><td>更安全</td></tr><tr><td>容量限制</td><td>单个 4KB 限制</td><td>理论上无明显限制</td></tr><tr><td>适用场景</td><td>保存轻量级信息</td><td>保存敏感信息和状态</td></tr></tbody></table><p>选择使用 <code>session</code> 或 <code>cookie</code> 应根据实际场景需求和安全性要求来决定。</p>]]></content>
    
    
    
    <tags>
      
      <tag>问题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker部署nuxt应用, 并支持部署自定义http server</title>
    <link href="/2021/08/11/docker%E9%83%A8%E7%BD%B2nuxt%E5%BA%94%E7%94%A8/"/>
    <url>/2021/08/11/docker%E9%83%A8%E7%BD%B2nuxt%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>前言: 最近在做一个前端项目。为了使用服务端渲染，使用 nuxt 写的。项目已经完成的差不多了。本来是采用 pm2 + nginx 反向代理的方式部署的应用的。</p><blockquote><p>但是最近有个新的需求就是。每次部署需要自定义 http 请求的接口地址 axios.defaults.baseURL</p></blockquote><p>于是就打算使用 docker 构建一个镜像。利用<code>docker run -d -e API_URL=&#123;api url&#125; ....</code>的形式来启动项目。</p><p>利用 docker 的 <strong>-e</strong> 参数可以向容器写入一个自定义的环境变量。做到前端可以通过环境变量的形式来调用 api 接口</p><p>例如 <code>axios.defaults.baseURL = process.env.API_URL </code></p><blockquote><p>但理想是美好的。现实总是残忍的。。。</p></blockquote><ul><li>构建镜像</li><li>写入自定义参数。启动 image 镜像</li><li>访问对应端口的项目</li></ul><p>发现项目能够正常访问。但是项目并没有读取到设置的环境变量。然后进入 docker 容器内部查看。发现容器内部也是生成了自定义读取的变量。但是 next 项目却无法通过 <code>process.env.API_URL</code> 这种形式来调取。这就很奇怪了。</p><p><img src="/../img/process.png" alt="image-20211116102527849"></p><p>经过一番搜索之后。在 nuxt 官方文档发现了 Runtime config properties（运行时配置属性） 这个配置项。</p><p>在 <code>next.config.js</code>中添加如下配置。那么我们在打包成 docker 镜像之后通过<code> λ docker run -d -e API_URL=https://nuxtjs.org</code> 这种形式注入的参数就可以在前端项目中通过环境变量的形式引用到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">publicRuntimeConfig</span>: &#123;<br>    <span class="hljs-attr">baseURL</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">BASE_URL</span> || <span class="hljs-string">&quot;https://nuxtjs.org&quot;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 nuxt plugins 中 引用的 axios 可以通过以下形式来调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">&#123; $axios, redirect, $config &#125;</span>) &#123;<br>  $axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">baseURL</span> = $config.<span class="hljs-property">API_URL</span>;<br>  $axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">timeout</span> = <span class="hljs-number">30000</span>;<br>  $axios.<span class="hljs-title function_">onError</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">500</span>) &#123;<br>      <span class="hljs-title function_">redirect</span>(<span class="hljs-string">&quot;/error&quot;</span>);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 vue 页面中可以通过 <code>this.$config.API_URL</code>来调用</p>]]></content>
    
    
    
    <tags>
      
      <tag>nuxt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习swift ui笔记</title>
    <link href="/2021/08/04/%E5%AD%A6%E4%B9%A0swift%20ui%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/04/%E5%AD%A6%E4%B9%A0swift%20ui%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="SwiftUI-学习笔记"><a href="#SwiftUI-学习笔记" class="headerlink" title="SwiftUI 学习笔记"></a>SwiftUI 学习笔记</h1><h3 id="视图操作"><a href="#视图操作" class="headerlink" title="视图操作"></a>视图操作</h3><blockquote><p>SwiftUI 常用方法 官方学习教程 <a href="https://developer.apple.com/tutorials/swiftui/">https://developer.apple.com/tutorials/swiftui/</a></p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">scaleEffect</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">scale</span>: <span class="hljs-type">CGSize</span>, <span class="hljs-params">anchor</span>: <span class="hljs-type">UnitPoint</span> <span class="hljs-operator">=</span> .center) -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span><br></code></pre></td></tr></table></figure><h5 id="相对于锚点，按给定的垂直和水平尺寸大小缩放此视图的渲染输出"><a href="#相对于锚点，按给定的垂直和水平尺寸大小缩放此视图的渲染输出" class="headerlink" title="相对于锚点，按给定的垂直和水平尺寸大小缩放此视图的渲染输出"></a>相对于锚点，按给定的垂直和水平尺寸大小缩放此视图的渲染输出</h5><ul><li><p><strong>scale</strong></p><p>相对于水平和垂直方向的缩放比</p></li><li><p><strong>anchor</strong></p><p>默认为 UnitPoint&#x2F;center 的点 定义视图中应用的位置</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">hueRotation</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">angle</span>: <span class="hljs-type">Angle</span>) -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>Angle(degrees: 180)</strong></p><p>对视图进行色调调整</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">grayscale</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>) -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>.grayscale(0.50)</strong></p><p>对视图添加灰度效果</p></li></ul><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">@inlinable</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">environmentObject</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">object</span>: <span class="hljs-type">T</span>) -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> <span class="hljs-keyword">where</span> <span class="hljs-type">T</span> : <span class="hljs-type">ObservableObject</span><br></code></pre></td></tr></table></figure><h5 id="向子元素-传递-ObservableObject-对象使数据可以被监听"><a href="#向子元素-传递-ObservableObject-对象使数据可以被监听" class="headerlink" title="向子元素 传递 ObservableObject 对象使数据可以被监听"></a>向子元素 传递 ObservableObject 对象使数据可以被监听</h5>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
