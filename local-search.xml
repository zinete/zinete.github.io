<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浏览器渲染原理</title>
    <link href="/2025/04/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"/>
    <url>/2025/04/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><p>浏览器的主要任务是将 HTML、CSS 和 JavaScript 等资源渲染为用户可以交互的图形界面。本篇文章将简要介绍浏览器渲染的整体流程和关键组件。</p><hr><p><img src="/../img/browser_rendering.png" alt="示意图"></p><h2 id="一、浏览器渲染流程概览"><a href="#一、浏览器渲染流程概览" class="headerlink" title="一、浏览器渲染流程概览"></a>一、浏览器渲染流程概览</h2><p>浏览器渲染的核心流程如下：</p><ol><li><strong>解析 HTML，构建 DOM 树</strong></li><li><strong>解析 CSS，构建 CSSOM 树</strong></li><li><strong>合并 DOM 和 CSSOM，生成渲染树（Render Tree）</strong></li><li><strong>布局（Layout）：计算每个节点的位置和大小</strong></li><li><strong>绘制（Painting）：将各个节点转换为屏幕上的像素</strong></li><li><strong>合成（Compositing）：将不同层的绘制结果合并输出到屏幕</strong></li></ol><hr><h2 id="二、关键组件解析"><a href="#二、关键组件解析" class="headerlink" title="二、关键组件解析"></a>二、关键组件解析</h2><h3 id="1-DOM（Document-Object-Model）"><a href="#1-DOM（Document-Object-Model）" class="headerlink" title="1. DOM（Document Object Model）"></a>1. DOM（Document Object Model）</h3><ul><li>将 HTML 文件解析为树状结构的对象模型</li><li>每个标签元素成为一个 DOM 节点</li></ul><h3 id="2-CSSOM（CSS-Object-Model）"><a href="#2-CSSOM（CSS-Object-Model）" class="headerlink" title="2. CSSOM（CSS Object Model）"></a>2. CSSOM（CSS Object Model）</h3><ul><li>将所有 CSS 样式解析为一棵样式规则树</li><li>规则包括样式继承、优先级、选择器等</li></ul><h3 id="3-Render-Tree（渲染树）"><a href="#3-Render-Tree（渲染树）" class="headerlink" title="3. Render Tree（渲染树）"></a>3. Render Tree（渲染树）</h3><ul><li>是由 DOM 和 CSSOM 合并生成</li><li>只包含需要显示的节点（例如不包含 <code>display: none</code> 的节点）</li></ul><hr><h2 id="三、Layout-阶段（又称-Reflow）"><a href="#三、Layout-阶段（又称-Reflow）" class="headerlink" title="三、Layout 阶段（又称 Reflow）"></a>三、Layout 阶段（又称 Reflow）</h2><ul><li>浏览器会根据 Render Tree 中的每个元素计算其具体的几何位置（宽、高、相对位置）</li><li>会受到盒模型、定位、字体大小等影响</li></ul><hr><h2 id="四、Painting-阶段"><a href="#四、Painting-阶段" class="headerlink" title="四、Painting 阶段"></a>四、Painting 阶段</h2><ul><li>浏览器将 Layout 阶段计算的几何信息转换为实际像素</li><li>涉及颜色填充、文字绘制、阴影、边框等</li></ul><hr><h2 id="五、Compositing（合成）"><a href="#五、Compositing（合成）" class="headerlink" title="五、Compositing（合成）"></a>五、Compositing（合成）</h2><ul><li>对包含多个图层的页面内容进行层合成</li><li>使用 GPU 加速的方式将各层合并，生成最终画面</li><li>常见触发合成的情况有：<code>transform</code>, <code>opacity</code>, <code>position: fixed</code>, <code>will-change</code> 等</li></ul><hr><h2 id="六、关键概念"><a href="#六、关键概念" class="headerlink" title="六、关键概念"></a>六、关键概念</h2><h3 id="Reflow（回流）"><a href="#Reflow（回流）" class="headerlink" title="Reflow（回流）"></a>Reflow（回流）</h3><ul><li>当元素的位置或尺寸发生变化时，需要重新计算布局</li><li>代价较大，尽量避免频繁触发</li></ul><h3 id="Repaint（重绘）"><a href="#Repaint（重绘）" class="headerlink" title="Repaint（重绘）"></a>Repaint（重绘）</h3><ul><li>当元素的样式发生变化，但不影响布局（如颜色、阴影等）</li><li>成本小于 Reflow，但仍有性能开销</li></ul><h3 id="GPU-加速"><a href="#GPU-加速" class="headerlink" title="GPU 加速"></a>GPU 加速</h3><ul><li>浏览器通过启用硬件加速，将合成任务交由 GPU 处理</li><li>提高复杂动画或大图滚动的性能</li></ul><hr><h2 id="七、性能优化建议"><a href="#七、性能优化建议" class="headerlink" title="七、性能优化建议"></a>七、性能优化建议</h2><ul><li>避免频繁操作 DOM，使用 DocumentFragment 或 requestAnimationFrame</li><li>使用类名而非内联样式以便样式合并</li><li>减少嵌套层级，避免复杂选择器</li><li>对动画元素使用 <code>will-change</code> 或 <code>transform/opacity</code> 触发 GPU 合成</li></ul><hr><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>浏览器渲染是一个涉及多个阶段的复杂过程，从资源加载到最终展示，中间需要处理大量的结构和样式信息。理解这些流程对于前端开发性能优化和调试渲染问题非常重要。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>武汉买房建议（2025）版</title>
    <link href="/2025/04/12/%E6%AD%A6%E6%B1%89%E4%B9%B0%E6%88%BF%E5%BB%BA%E8%AE%AE%EF%BC%882025%EF%BC%89%E7%89%88/"/>
    <url>/2025/04/12/%E6%AD%A6%E6%B1%89%E4%B9%B0%E6%88%BF%E5%BB%BA%E8%AE%AE%EF%BC%882025%EF%BC%89%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="武汉买房攻略建议（2025-版）"><a href="#武汉买房攻略建议（2025-版）" class="headerlink" title="武汉买房攻略建议（2025 版）"></a>武汉买房攻略建议（2025 版）</h1><p>武汉作为中部核心城市，吸引了大量人才和家庭落户。买房是人生中的一件大事，尤其在武汉这样交通发达、区域多样的大都市，更需要全面的准备和理性决策。本文将为你详细解析武汉买房的全流程及建议。</p><hr><h2 id="🧭-一、买房前的准备"><a href="#🧭-一、买房前的准备" class="headerlink" title="🧭 一、买房前的准备"></a>🧭 一、买房前的准备</h2><h3 id="1-明确购房目的"><a href="#1-明确购房目的" class="headerlink" title="1. 明确购房目的"></a>1. 明确购房目的</h3><ul><li><strong>自住</strong>：优先考虑通勤距离、教育资源、医疗配套。</li><li><strong>投资</strong>：重点关注租金回报率、潜力区域。</li><li><strong>学区房</strong>：关注学区划分、教育政策动态。</li></ul><h3 id="2-了解购房资格"><a href="#2-了解购房资格" class="headerlink" title="2. 了解购房资格"></a>2. 了解购房资格</h3><ul><li>不限购，随便买</li></ul><h3 id="3-预算规划"><a href="#3-预算规划" class="headerlink" title="3. 预算规划"></a>3. 预算规划</h3><ul><li><strong>首付比例</strong>：<ul><li>首套房最低 15%，二套房 25%。</li></ul></li><li><strong>贷款利率</strong>：<ul><li>根据规定，2024 年 5 月 18 日前发放的期限在 1 年以上的个人住房公积金贷款，自 2025 年 1 月 1 日起，执行调整后利率。调整后，5 年以下(含 5 年)和 5 年以上首套个人住房公积金贷款利率分别为 2.35%和 2.85%，5 年以下(含 5 年) 和 5 年以上第二套个人住房公积金贷款利率分别为 2.775%和 3.325%。2024 年 5 月 18 日前发放的期限在 1 年及 1 年以内的个人住房公积金贷款，仍执行合同利率，不分段计息。</li></ul></li><li><strong>月供压力测试</strong>：<ul><li>建议控制在家庭月收入的 50%以内。</li></ul></li></ul><hr><h2 id="🏙️-二、武汉热门购房区域推荐"><a href="#🏙️-二、武汉热门购房区域推荐" class="headerlink" title="🏙️ 二、武汉热门购房区域推荐"></a>🏙️ 二、武汉热门购房区域推荐</h2><h3 id="1-武昌区"><a href="#1-武昌区" class="headerlink" title="1. 武昌区"></a>1. 武昌区</h3><ul><li><strong>优点</strong>：教育资源密集、生活配套成熟。</li><li><strong>热门板块</strong>：中南路、徐东、水果湖、南湖。</li><li><strong>适合人群</strong>：有学龄儿童的家庭、自住人群。</li></ul><h3 id="2-江汉区-江岸区"><a href="#2-江汉区-江岸区" class="headerlink" title="2. 江汉区 &#x2F; 江岸区"></a>2. 江汉区 &#x2F; 江岸区</h3><ul><li><strong>优点</strong>：交通发达，临近汉口火车站&#x2F;长江。</li><li><strong>热门板块</strong>：万松园、王家墩 CBD、二七路。</li><li><strong>适合人群</strong>：工作在汉口、重视生活便利性者。</li></ul><h3 id="3-东湖高新区（光谷）"><a href="#3-东湖高新区（光谷）" class="headerlink" title="3. 东湖高新区（光谷）"></a>3. 东湖高新区（光谷）</h3><ul><li><strong>优点</strong>：科技产业集群、潜力巨大。</li><li><strong>热门板块</strong>：光谷东、关山大道、藏龙岛。</li><li><strong>适合人群</strong>：年轻人、IT&#x2F;高校从业者、投资客。</li></ul><h3 id="4-汉阳区-蔡甸区"><a href="#4-汉阳区-蔡甸区" class="headerlink" title="4. 汉阳区 &#x2F; 蔡甸区"></a>4. 汉阳区 &#x2F; 蔡甸区</h3><ul><li><strong>优点</strong>：新盘多，性价比高。</li><li><strong>热门板块</strong>：四新、国博、知音湖。</li><li><strong>适合人群</strong>：刚需、预算有限购房者。</li></ul><hr><h2 id="🏡-三、选房-看房建议"><a href="#🏡-三、选房-看房建议" class="headerlink" title="🏡 三、选房&amp;看房建议"></a>🏡 三、选房&amp;看房建议</h2><ol><li><strong>实地看房</strong>：不要只看宣传图，实地了解周边配套、交通、环境。</li><li><strong>看开发商资质</strong>：优先选择品牌开发商，口碑好、后期维权风险低。</li><li><strong>关注物业管理</strong>：好的物业可以大大提高生活质量。</li><li><strong>楼层&#x2F;朝向选择</strong>：<ul><li>朝南最佳，避开低层&#x2F;顶楼；</li><li>注意采光与通风。</li></ul></li></ol><hr><h2 id="📝-四、购房流程简要"><a href="#📝-四、购房流程简要" class="headerlink" title="📝 四、购房流程简要"></a>📝 四、购房流程简要</h2><ol><li><strong>看房选房</strong> →</li><li><strong>签订认购书</strong> →</li><li><strong>缴纳定金</strong> →</li><li><strong>签订购房合同</strong> →</li><li><strong>办理贷款</strong> →</li><li><strong>缴税过户</strong> →</li><li><strong>验房收房</strong></li></ol><hr><h2 id="⚠️-五、购房注意事项"><a href="#⚠️-五、购房注意事项" class="headerlink" title="⚠️ 五、购房注意事项"></a>⚠️ 五、购房注意事项</h2><ul><li><strong>查看五证是否齐全</strong>：预售证尤其关键。</li><li><strong>合同条款仔细核对</strong>：面积、价格、交付标准要明确。</li><li><strong>防范虚假宣传</strong>：包括学区、地铁规划、未来配套等。</li><li><strong>交房时间与违约责任</strong>：写清楚时间节点与补偿方式。</li></ul><hr><h2 id="📌-六、实用工具推荐"><a href="#📌-六、实用工具推荐" class="headerlink" title="📌 六、实用工具推荐"></a>📌 六、实用工具推荐</h2><ul><li>武汉房地产信息网（官方）</li><li>链家&#x2F;贝壳等平台（找房用）</li><li>公积金官网（贷款计算器）</li><li>地铁规划图（查看通勤路线）</li></ul><hr><h2 id="🎯-结语"><a href="#🎯-结语" class="headerlink" title="🎯 结语"></a>🎯 结语</h2><p>武汉房价相对北上广仍有空间，无论是自住还是投资，都需要理性分析、全面对比。如果你是<strong>刚需</strong>，务必优先满足居住舒适与通勤便利；如果你是<strong>投资客</strong>，建议关注东湖高新等潜力板块，避免盲目追高。</p><p>祝你早日找到心仪的家！</p><hr><p><em>更新时间：2025 年 4 月</em></p>]]></content>
    
    
    <categories>
      
      <category>房产</category>
      
    </categories>
    
    
    <tags>
      
      <tag>买房</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何理解 JavaScript 中的事件循环</title>
    <link href="/2024/07/12/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20JavaScript%20%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2024/07/12/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20JavaScript%20%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="如何理解-JavaScript-中的事件循环（Event-Loop）"><a href="#如何理解-JavaScript-中的事件循环（Event-Loop）" class="headerlink" title="如何理解 JavaScript 中的事件循环（Event Loop）"></a>如何理解 JavaScript 中的事件循环（Event Loop）</h1><p>JavaScript 是一种<strong>单线程</strong>语言，它通过事件循环（Event Loop）机制来实现异步操作的调度与执行。理解事件循环有助于我们更好地编写异步代码，避免一些常见的“回调陷阱”或异步顺序错误。</p><hr><p><img src="/../img/eventloop.png" alt="示意图"></p><h2 id="1-什么是事件循环？"><a href="#1-什么是事件循环？" class="headerlink" title="1. 什么是事件循环？"></a>1. 什么是事件循环？</h2><p>事件循环是一种协调机制，用于决定哪些代码在何时执行，特别是在处理异步任务（如定时器、网络请求、Promise 等）时。事件循环的核心流程包括：</p><ol><li>执行同步代码（同步任务进入调用栈）</li><li>执行所有微任务（Microtasks）</li><li>从宏任务队列中取出下一个宏任务执行</li><li>重复上述过程</li></ol><hr><h2 id="2-同步任务-vs-异步任务"><a href="#2-同步任务-vs-异步任务" class="headerlink" title="2. 同步任务 vs 异步任务"></a>2. 同步任务 vs 异步任务</h2><ul><li><strong>同步任务</strong>：立即执行，按顺序排列在调用栈中。</li><li><strong>异步任务</strong>：交由浏览器或 Node 的 Web API 执行，完成后加入任务队列中等待执行。</li></ul><hr><h2 id="3-微任务与宏任务"><a href="#3-微任务与宏任务" class="headerlink" title="3. 微任务与宏任务"></a>3. 微任务与宏任务</h2><table><thead><tr><th>类型</th><th>举例</th><th>特点</th></tr></thead><tbody><tr><td><strong>微任务 Microtask</strong></td><td>Promise.then、MutationObserver、queueMicrotask</td><td>在当前宏任务完成后立即执行</td></tr><tr><td><strong>宏任务 MacroTask</strong></td><td>setTimeout、setInterval、I&#x2F;O、setImmediate</td><td>会排队等待事件循环进入下一个周期</td></tr></tbody></table><hr><h2 id="4-执行顺序示例"><a href="#4-执行顺序示例" class="headerlink" title="4. 执行顺序示例"></a>4. 执行顺序示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3&quot;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;4&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span>;<br><span class="hljs-number">4</span>;<br><span class="hljs-number">3</span>;<br><span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h3 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h3><ol><li><code>console.log(&#39;1&#39;)</code> 和 <code>console.log(&#39;4&#39;)</code> 是同步任务，先执行。</li><li><code>setTimeout</code> 是宏任务，进入任务队列。</li><li><code>Promise.then</code> 是微任务，在当前宏任务执行完后立即执行。</li><li>所以先输出 3，然后才是 <code>setTimeout</code> 的 2。</li></ol><h2 id="5-setTimeout-fn-0-并不是“立即执行”"><a href="#5-setTimeout-fn-0-并不是“立即执行”" class="headerlink" title="5. setTimeout(fn, 0) 并不是“立即执行”"></a>5. setTimeout(fn, 0) 并不是“立即执行”</h2><p>即便设置为 0 毫秒，setTimeout 回调也不会在当前调用栈执行完前运行，因为它是宏任务，会等到所有当前宏任务和微任务完成后才进入执行。</p><h2 id="6-实战技巧：分批执行避免阻塞"><a href="#6-实战技巧：分批执行避免阻塞" class="headerlink" title="6. 实战技巧：分批执行避免阻塞"></a>6. 实战技巧：分批执行避免阻塞</h2><p>如果你有一个很大的循环操作，不建议一次性执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不推荐：可能阻塞 UI</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e9</span>; i++) &#123;<br>  <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以改为使用 setTimeout 分批执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">chunkedTask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>    <span class="hljs-comment">// do something</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (moreWork) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(chunkedTask, <span class="hljs-number">0</span>); <span class="hljs-comment">// 让出执行权</span><br>  &#125;<br>&#125;<br><span class="hljs-title function_">chunkedTask</span>();<br></code></pre></td></tr></table></figure><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><ul><li><code>JavaScript</code> 是单线程语言，通过事件循环处理异步任务。微任务优先于宏任务执行。</li><li><code>Promise.then</code> 总是在同步任务之后，<code>setTimeout</code> 之后执行。</li><li>理解事件循环，有助于编写更加流畅、性能更佳的前端应用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些问题记录</title>
    <link href="/2023/05/07/%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/05/07/%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一些问题记录"><a href="#一些问题记录" class="headerlink" title="一些问题记录"></a>一些问题记录</h1><blockquote><p>git 代码提交验证问题</p></blockquote><p>配置 gpg 之后如果提交代码失败，需要在终端执行<code> export GPG_TTY=$(tty)</code><br>然后再次提交，按照提示输入 gpg 配置的密码即可</p><p><code>gpg --full-generate-key</code> 交互式命令创建新的 gpg key</p><p><code>gpg --list-keys</code> 查看创建的所有 gpg key</p><p><code>gpg --armor --export zhenghui@zinete.com</code> 查看指定邮箱 gpg 公钥</p>]]></content>
    
    
    <categories>
      
      <category>问题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手动执行添加SSH密钥</title>
    <link href="/2022/10/04/%E6%89%8B%E5%8A%A8%E6%89%A7%E8%A1%8C%E6%B7%BB%E5%8A%A0SSH%E5%AF%86%E9%92%A5/"/>
    <url>/2022/10/04/%E6%89%8B%E5%8A%A8%E6%89%A7%E8%A1%8C%E6%B7%BB%E5%8A%A0SSH%E5%AF%86%E9%92%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="自动加载-SSH-密钥并使用-macOS-钥匙串"><a href="#自动加载-SSH-密钥并使用-macOS-钥匙串" class="headerlink" title="自动加载 SSH 密钥并使用 macOS 钥匙串"></a>自动加载 SSH 密钥并使用 macOS 钥匙串</h1><p>为了避免每次重启机器都需要执行 <code>ssh-add --apple-use-keychain</code> 命令，可以按照以下步骤进行配置：</p><h2 id="1-确保-SSH-密钥已添加到钥匙串"><a href="#1-确保-SSH-密钥已添加到钥匙串" class="headerlink" title="1. 确保 SSH 密钥已添加到钥匙串"></a>1. 确保 SSH 密钥已添加到钥匙串</h2><p>执行以下命令，将密钥永久添加到钥匙串中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-add --apple-use-keychain ~/.ssh/zinete.com<br></code></pre></td></tr></table></figure><h2 id="2-配置-SSH-客户端加载密钥"><a href="#2-配置-SSH-客户端加载密钥" class="headerlink" title="2. 配置 SSH 客户端加载密钥"></a>2. 配置 SSH 客户端加载密钥</h2><p>编辑或创建 <code>~/.ssh/config</code> 文件，添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Host *<br>  AddKeysToAgent yes<br>  UseKeychain yes<br>  IdentityFile ~/.ssh/zinete.com<br></code></pre></td></tr></table></figure><h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><ul><li><code>AddKeysToAgent yes</code>：自动将密钥添加到 SSH Agent。</li><li><code>UseKeychain yes</code>：允许密钥存储在 macOS 钥匙串中。</li><li><code>IdentityFile</code>：指定使用的私钥文件。</li></ul><h2 id="3-确保-SSH-Agent-启动"><a href="#3-确保-SSH-Agent-启动" class="headerlink" title="3. 确保 SSH Agent 启动"></a>3. 确保 SSH Agent 启动</h2><p>macOS 默认会启动 SSH Agent，但可以手动验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ssh-agent -s)</span>&quot;</span><br></code></pre></td></tr></table></figure><h2 id="4-验证配置"><a href="#4-验证配置" class="headerlink" title="4. 验证配置"></a>4. 验证配置</h2><p>执行以下命令检查密钥是否自动加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-add -l<br></code></pre></td></tr></table></figure><p>如果显示了密钥的指纹，说明配置成功。</p><hr><p>通过上述配置，SSH 密钥将在重启后自动从 macOS 钥匙串加载，无需手动执行 <code>ssh-add</code>。</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Session和Cookie的区别</title>
    <link href="/2022/06/03/Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/06/03/Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="Session-和-Cookie-的区别"><a href="#Session-和-Cookie-的区别" class="headerlink" title="Session 和 Cookie 的区别"></a>Session 和 Cookie 的区别</h1><p><code>session</code> 和 <code>cookie</code> 是用于在客户端与服务器之间保持状态的两种技术，它们有一些显著的区别：</p><h2 id="1-存储位置"><a href="#1-存储位置" class="headerlink" title="1. 存储位置"></a>1. 存储位置</h2><ul><li><strong>Cookie</strong><br>存储在客户端（浏览器），数据会随着每次请求自动发送到服务器。</li><li><strong>Session</strong><br>存储在服务器，客户端只保存一个唯一的 <code>session_id</code>，通过它找到对应的会话数据。</li></ul><h2 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h2><ul><li><strong>Cookie</strong><br>默认会在浏览器关闭后失效，除非设置了 <code>expires</code> 或 <code>max-age</code> 属性，可以持久存储。</li><li><strong>Session</strong><br>通常在用户关闭浏览器或服务器设定的超时时间到期后失效（如 30 分钟未操作）。</li></ul><h2 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3. 安全性"></a>3. 安全性</h2><ul><li><strong>Cookie</strong><br>数据存储在客户端，容易被窃取或篡改（如通过 XSS 攻击）。可以通过 <code>HttpOnly</code> 和 <code>Secure</code> 属性提高安全性。</li><li><strong>Session</strong><br>数据存储在服务器，安全性更高，但需要依赖 <code>session_id</code> 的安全传递和存储。</li></ul><h2 id="4-容量限制"><a href="#4-容量限制" class="headerlink" title="4. 容量限制"></a>4. 容量限制</h2><ul><li><strong>Cookie</strong><br>单个 Cookie 的大小限制为 4KB 左右，且每个域名最多存储 20 个左右（不同浏览器限制不同）。</li><li><strong>Session</strong><br>理论上不受容量限制，实际受服务器内存或存储空间的影响。</li></ul><h2 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5. 适用场景"></a>5. 适用场景</h2><ul><li><strong>Cookie</strong><br>常用于保存一些小型的、非敏感的数据，例如用户偏好设置、记住用户名等。</li><li><strong>Session</strong><br>常用于需要更高安全性或需要保存用户状态的场景，例如用户登录状态、购物车信息等。</li></ul><h2 id="6-性能影响"><a href="#6-性能影响" class="headerlink" title="6. 性能影响"></a>6. 性能影响</h2><ul><li><strong>Cookie</strong><br>由于每次请求都会附加到 HTTP 请求头中，大量使用可能增加网络开销。</li><li><strong>Session</strong><br>存储在服务器，会消耗服务器资源。如果并发用户过多，可能导致性能问题。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>特性</th><th>Cookie</th><th>Session</th></tr></thead><tbody><tr><td>存储位置</td><td>客户端</td><td>服务器</td></tr><tr><td>生命周期</td><td>可配置</td><td>浏览器关闭或超时后失效</td></tr><tr><td>安全性</td><td>易被窃取&#x2F;篡改</td><td>更安全</td></tr><tr><td>容量限制</td><td>单个 4KB 限制</td><td>理论上无明显限制</td></tr><tr><td>适用场景</td><td>保存轻量级信息</td><td>保存敏感信息和状态</td></tr></tbody></table><p>选择使用 <code>session</code> 或 <code>cookie</code> 应根据实际场景需求和安全性要求来决定。</p>]]></content>
    
    
    
    <tags>
      
      <tag>问题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker部署Nuxt应用, 并支持部署自定义http server</title>
    <link href="/2021/08/11/docker%E9%83%A8%E7%BD%B2nuxt%E5%BA%94%E7%94%A8/"/>
    <url>/2021/08/11/docker%E9%83%A8%E7%BD%B2nuxt%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>前言: 最近在做一个前端项目。为了使用服务端渲染，使用 nuxt 写的。项目已经完成的差不多了。本来是采用 pm2 + nginx 反向代理的方式部署的应用的。</p><blockquote><p>但是最近有个新的需求就是。每次部署需要自定义 http 请求的接口地址 axios.defaults.baseURL</p></blockquote><p>于是就打算使用 docker 构建一个镜像。利用<code>docker run -d -e API_URL=&#123;api url&#125; ....</code>的形式来启动项目。</p><p>利用 docker 的 <strong>-e</strong> 参数可以向容器写入一个自定义的环境变量。做到前端可以通过环境变量的形式来调用 api 接口</p><p>例如 <code>axios.defaults.baseURL = process.env.API_URL </code></p><blockquote><p>但理想是美好的。现实总是残忍的。。。</p></blockquote><ul><li>构建镜像</li><li>写入自定义参数。启动 image 镜像</li><li>访问对应端口的项目</li></ul><p>发现项目能够正常访问。但是项目并没有读取到设置的环境变量。然后进入 docker 容器内部查看。发现容器内部也是生成了自定义读取的变量。但是 next 项目却无法通过 <code>process.env.API_URL</code> 这种形式来调取。这就很奇怪了。</p><p><img src="/../img/process.png" alt="image-20211116102527849"></p><p>经过一番搜索之后。在 nuxt 官方文档发现了 Runtime config properties（运行时配置属性） 这个配置项。</p><p>在 <code>next.config.js</code>中添加如下配置。那么我们在打包成 docker 镜像之后通过<code> λ docker run -d -e API_URL=https://nuxtjs.org</code> 这种形式注入的参数就可以在前端项目中通过环境变量的形式引用到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">publicRuntimeConfig</span>: &#123;<br>    <span class="hljs-attr">baseURL</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">BASE_URL</span> || <span class="hljs-string">&quot;https://nuxtjs.org&quot;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 nuxt plugins 中 引用的 axios 可以通过以下形式来调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">&#123; $axios, redirect, $config &#125;</span>) &#123;<br>  $axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">baseURL</span> = $config.<span class="hljs-property">API_URL</span>;<br>  $axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">timeout</span> = <span class="hljs-number">30000</span>;<br>  $axios.<span class="hljs-title function_">onError</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">500</span>) &#123;<br>      <span class="hljs-title function_">redirect</span>(<span class="hljs-string">&quot;/error&quot;</span>);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 vue 页面中可以通过 <code>this.$config.API_URL</code>来调用</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nuxt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习swift ui笔记</title>
    <link href="/2021/08/04/%E5%AD%A6%E4%B9%A0swift%20ui%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/04/%E5%AD%A6%E4%B9%A0swift%20ui%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="SwiftUI-学习笔记"><a href="#SwiftUI-学习笔记" class="headerlink" title="SwiftUI 学习笔记"></a>SwiftUI 学习笔记</h1><h3 id="视图操作"><a href="#视图操作" class="headerlink" title="视图操作"></a>视图操作</h3><blockquote><p>SwiftUI 常用方法 官方学习教程 <a href="https://developer.apple.com/tutorials/swiftui/">https://developer.apple.com/tutorials/swiftui/</a></p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">scaleEffect</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">scale</span>: <span class="hljs-type">CGSize</span>, <span class="hljs-params">anchor</span>: <span class="hljs-type">UnitPoint</span> <span class="hljs-operator">=</span> .center) -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span><br></code></pre></td></tr></table></figure><h5 id="相对于锚点，按给定的垂直和水平尺寸大小缩放此视图的渲染输出"><a href="#相对于锚点，按给定的垂直和水平尺寸大小缩放此视图的渲染输出" class="headerlink" title="相对于锚点，按给定的垂直和水平尺寸大小缩放此视图的渲染输出"></a>相对于锚点，按给定的垂直和水平尺寸大小缩放此视图的渲染输出</h5><ul><li><p><strong>scale</strong></p><p>相对于水平和垂直方向的缩放比</p></li><li><p><strong>anchor</strong></p><p>默认为 UnitPoint&#x2F;center 的点 定义视图中应用的位置</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">hueRotation</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">angle</span>: <span class="hljs-type">Angle</span>) -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>Angle(degrees: 180)</strong></p><p>对视图进行色调调整</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">grayscale</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>) -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>.grayscale(0.50)</strong></p><p>对视图添加灰度效果</p></li></ul><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">@inlinable</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">environmentObject</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">object</span>: <span class="hljs-type">T</span>) -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> <span class="hljs-keyword">where</span> <span class="hljs-type">T</span> : <span class="hljs-type">ObservableObject</span><br></code></pre></td></tr></table></figure><h5 id="向子元素-传递-ObservableObject-对象使数据可以被监听"><a href="#向子元素-传递-ObservableObject-对象使数据可以被监听" class="headerlink" title="向子元素 传递 ObservableObject 对象使数据可以被监听"></a>向子元素 传递 ObservableObject 对象使数据可以被监听</h5>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
